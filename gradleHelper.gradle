/**
 * Load properties file into the project
 * @param fileName properties file name
 */
def loadProperties(def fileName) {
    def propertiesFile = file(fileName)
    if (!propertiesFile.exists()) {
        println("Properties file missing: " + fileName)
        return
    }

    Properties properties = new Properties()
    properties.load(propertiesFile.newReader("UTF-8"))
    properties.each { property ->
        // all extra properties must be set in: project.ext
        project.ext.set(property.key, property.value)
    }
}

/**
 * Get the value for the secret key
 *
 * @param key the key identifier
 * @param defaultValue default value of such key is missing
 * @return the value behind the key or the defaultValue
 */
def getSecret(def key, def defaultValue = null) {
    return project.hasProperty(key) ? project.property(key) : defaultValue
}

/**
 *
 * build fabric properties file, if missing
 */
def buildFabricPropertiesIfNeeded() {
    def propertiesFile = file("fabric.properties")
    if (!propertiesFile.exists()) {
        def commentMessage = "This is autogenerated crashlytics property from system environment to prevent key to be committed to source control."
        ant.propertyfile(file: "fabric.properties", comment: commentMessage) {
            entry(key: "apiSecret", value: getSecret("fabricApiSecret"), operation: "=")
            entry(key: "apiKey", value: getSecret("fabricApiKey"), operation: "=")
        }
    }
}

/**
 *
 * @return CircleCI build branch or "localdev"
 */
def getBranchName() {
    def branch = System.getenv("CIRCLE_BRANCH")
    if (branch?.length() > 0) {
        branch = branch.trim()
    } else {
        // fallback for local dev
        branch = "localdev"
    }

    return branch
}

/**
 *
 * @return the branch name containing only lowercase alphabetic symbols
 */
def getSafeBranchIdentifier() {
    def branch = getBranchName()
    // remove all non alphabetic symbols
    branch = branch.replaceAll("[^a-zA-Z]", "").toLowerCase()

    if ("master".equalsIgnoreCase(branch)) {
        // do not generate suffix for "master" branch
        return ""
    }

    return branch
}

/**
 *
 * @return Generated changelog from the last 10 GitHub commits
 */
def getChangelog() {
    if ("localdev".equalsIgnoreCase(getBranchName())) {
        return "Local development build"
    }

    def logCmd = 'git log --oneline --no-decorate -n 10'
    def logs = logCmd.execute().text.trim()
    def items = []

    if (logs.length() > 0) {
        def lines = logs.split("\n")
        for (int i = 0; i < lines.length; i++) {
            items.add(String.format("%02d) %s", i + 1, lines[i]))
        }
    }

    return items.join("\n")
}

/**
 *
 * @return CI build number or a generated one
 */
def getBuildNumber() {
    def circleBranch = System.getenv("CIRCLE_BUILD_NUM")
    if (circleBranch?.length() > 0) {
        // CircleCI build number
        return circleBranch as int
    }

    // fallback mechanism for non CI env
    return (versionMajor.toInteger() * 10000) + (versionMinor.toInteger() * 100) + (versionPatch.toInteger())
}

/**
 *
 * @return version string identifier (major.minor.buildNumber[-branch])
 */
def getVersionAsString() {
    def buildNumber = getBuildNumber()
    def branchSuffix = getSafeBranchIdentifier()
    if (branchSuffix?.length() > 0) {
        branchSuffix = "-$branchSuffix"
    } else {
        branchSuffix = ""
    }

    return "$versionMajor.$versionMinor.$buildNumber$branchSuffix"
}

// Export methods by turning them into closures
ext {
    buildFabricPropertiesIfNeeded = this.&buildFabricPropertiesIfNeeded
    getSecret = this.&getSecret
    loadProperties = this.&loadProperties
    getChangelog = this.&getChangelog
    getBuildNumber = this.&getBuildNumber
    getVersionAsString = this.&getVersionAsString
    getSafeBranchIdentifier = this.&getSafeBranchIdentifier
}